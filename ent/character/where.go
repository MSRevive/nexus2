// Code generated by entc, DO NOT EDIT.

package character

import (
	"entgo.io/ent/dialect/sql"
	"github.com/google/uuid"
	"github.com/msrevive/nexus2/ent/predicate"
)

// ID filters vertices based on their ID field.
func ID(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDEQ applies the EQ predicate on the ID field.
func IDEQ(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldID), id))
	})
}

// IDNEQ applies the NEQ predicate on the ID field.
func IDNEQ(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldID), id))
	})
}

// IDIn applies the In predicate on the ID field.
func IDIn(ids ...uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.In(s.C(FieldID), v...))
	})
}

// IDNotIn applies the NotIn predicate on the ID field.
func IDNotIn(ids ...uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(ids) == 0 {
			s.Where(sql.False())
			return
		}
		v := make([]interface{}, len(ids))
		for i := range v {
			v[i] = ids[i]
		}
		s.Where(sql.NotIn(s.C(FieldID), v...))
	})
}

// IDGT applies the GT predicate on the ID field.
func IDGT(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldID), id))
	})
}

// IDGTE applies the GTE predicate on the ID field.
func IDGTE(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldID), id))
	})
}

// IDLT applies the LT predicate on the ID field.
func IDLT(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldID), id))
	})
}

// IDLTE applies the LTE predicate on the ID field.
func IDLTE(id uuid.UUID) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldID), id))
	})
}

// Steamid applies equality check predicate on the "steamid" field. It's identical to SteamidEQ.
func Steamid(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSteamid), v))
	})
}

// Slot applies equality check predicate on the "slot" field. It's identical to SlotEQ.
func Slot(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSlot), v))
	})
}

// Name applies equality check predicate on the "name" field. It's identical to NameEQ.
func Name(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// Gender applies equality check predicate on the "gender" field. It's identical to GenderEQ.
func Gender(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGender), v))
	})
}

// Race applies equality check predicate on the "race" field. It's identical to RaceEQ.
func Race(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRace), v))
	})
}

// Flags applies equality check predicate on the "flags" field. It's identical to FlagsEQ.
func Flags(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFlags), v))
	})
}

// Quickslots applies equality check predicate on the "quickslots" field. It's identical to QuickslotsEQ.
func Quickslots(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuickslots), v))
	})
}

// Quests applies equality check predicate on the "quests" field. It's identical to QuestsEQ.
func Quests(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuests), v))
	})
}

// Guild applies equality check predicate on the "guild" field. It's identical to GuildEQ.
func Guild(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGuild), v))
	})
}

// Kills applies equality check predicate on the "kills" field. It's identical to KillsEQ.
func Kills(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldKills), v))
	})
}

// Gold applies equality check predicate on the "gold" field. It's identical to GoldEQ.
func Gold(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGold), v))
	})
}

// Skills applies equality check predicate on the "skills" field. It's identical to SkillsEQ.
func Skills(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSkills), v))
	})
}

// Pets applies equality check predicate on the "pets" field. It's identical to PetsEQ.
func Pets(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPets), v))
	})
}

// Health applies equality check predicate on the "health" field. It's identical to HealthEQ.
func Health(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHealth), v))
	})
}

// Mana applies equality check predicate on the "mana" field. It's identical to ManaEQ.
func Mana(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMana), v))
	})
}

// Equipped applies equality check predicate on the "equipped" field. It's identical to EquippedEQ.
func Equipped(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEquipped), v))
	})
}

// Lefthand applies equality check predicate on the "lefthand" field. It's identical to LefthandEQ.
func Lefthand(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLefthand), v))
	})
}

// Righthand applies equality check predicate on the "righthand" field. It's identical to RighthandEQ.
func Righthand(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRighthand), v))
	})
}

// Spells applies equality check predicate on the "spells" field. It's identical to SpellsEQ.
func Spells(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSpells), v))
	})
}

// Spellbook applies equality check predicate on the "spellbook" field. It's identical to SpellbookEQ.
func Spellbook(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSpellbook), v))
	})
}

// Bags applies equality check predicate on the "bags" field. It's identical to BagsEQ.
func Bags(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBags), v))
	})
}

// Sheaths applies equality check predicate on the "sheaths" field. It's identical to SheathsEQ.
func Sheaths(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSheaths), v))
	})
}

// SteamidEQ applies the EQ predicate on the "steamid" field.
func SteamidEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSteamid), v))
	})
}

// SteamidNEQ applies the NEQ predicate on the "steamid" field.
func SteamidNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSteamid), v))
	})
}

// SteamidIn applies the In predicate on the "steamid" field.
func SteamidIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSteamid), v...))
	})
}

// SteamidNotIn applies the NotIn predicate on the "steamid" field.
func SteamidNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSteamid), v...))
	})
}

// SteamidGT applies the GT predicate on the "steamid" field.
func SteamidGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSteamid), v))
	})
}

// SteamidGTE applies the GTE predicate on the "steamid" field.
func SteamidGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSteamid), v))
	})
}

// SteamidLT applies the LT predicate on the "steamid" field.
func SteamidLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSteamid), v))
	})
}

// SteamidLTE applies the LTE predicate on the "steamid" field.
func SteamidLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSteamid), v))
	})
}

// SteamidContains applies the Contains predicate on the "steamid" field.
func SteamidContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSteamid), v))
	})
}

// SteamidHasPrefix applies the HasPrefix predicate on the "steamid" field.
func SteamidHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSteamid), v))
	})
}

// SteamidHasSuffix applies the HasSuffix predicate on the "steamid" field.
func SteamidHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSteamid), v))
	})
}

// SteamidEqualFold applies the EqualFold predicate on the "steamid" field.
func SteamidEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSteamid), v))
	})
}

// SteamidContainsFold applies the ContainsFold predicate on the "steamid" field.
func SteamidContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSteamid), v))
	})
}

// SlotEQ applies the EQ predicate on the "slot" field.
func SlotEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSlot), v))
	})
}

// SlotNEQ applies the NEQ predicate on the "slot" field.
func SlotNEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSlot), v))
	})
}

// SlotIn applies the In predicate on the "slot" field.
func SlotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSlot), v...))
	})
}

// SlotNotIn applies the NotIn predicate on the "slot" field.
func SlotNotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSlot), v...))
	})
}

// SlotGT applies the GT predicate on the "slot" field.
func SlotGT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSlot), v))
	})
}

// SlotGTE applies the GTE predicate on the "slot" field.
func SlotGTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSlot), v))
	})
}

// SlotLT applies the LT predicate on the "slot" field.
func SlotLT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSlot), v))
	})
}

// SlotLTE applies the LTE predicate on the "slot" field.
func SlotLTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSlot), v))
	})
}

// NameEQ applies the EQ predicate on the "name" field.
func NameEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldName), v))
	})
}

// NameNEQ applies the NEQ predicate on the "name" field.
func NameNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldName), v))
	})
}

// NameIn applies the In predicate on the "name" field.
func NameIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldName), v...))
	})
}

// NameNotIn applies the NotIn predicate on the "name" field.
func NameNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldName), v...))
	})
}

// NameGT applies the GT predicate on the "name" field.
func NameGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldName), v))
	})
}

// NameGTE applies the GTE predicate on the "name" field.
func NameGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldName), v))
	})
}

// NameLT applies the LT predicate on the "name" field.
func NameLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldName), v))
	})
}

// NameLTE applies the LTE predicate on the "name" field.
func NameLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldName), v))
	})
}

// NameContains applies the Contains predicate on the "name" field.
func NameContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldName), v))
	})
}

// NameHasPrefix applies the HasPrefix predicate on the "name" field.
func NameHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldName), v))
	})
}

// NameHasSuffix applies the HasSuffix predicate on the "name" field.
func NameHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldName), v))
	})
}

// NameEqualFold applies the EqualFold predicate on the "name" field.
func NameEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldName), v))
	})
}

// NameContainsFold applies the ContainsFold predicate on the "name" field.
func NameContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldName), v))
	})
}

// GenderEQ applies the EQ predicate on the "gender" field.
func GenderEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGender), v))
	})
}

// GenderNEQ applies the NEQ predicate on the "gender" field.
func GenderNEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGender), v))
	})
}

// GenderIn applies the In predicate on the "gender" field.
func GenderIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGender), v...))
	})
}

// GenderNotIn applies the NotIn predicate on the "gender" field.
func GenderNotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGender), v...))
	})
}

// GenderGT applies the GT predicate on the "gender" field.
func GenderGT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGender), v))
	})
}

// GenderGTE applies the GTE predicate on the "gender" field.
func GenderGTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGender), v))
	})
}

// GenderLT applies the LT predicate on the "gender" field.
func GenderLT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGender), v))
	})
}

// GenderLTE applies the LTE predicate on the "gender" field.
func GenderLTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGender), v))
	})
}

// RaceEQ applies the EQ predicate on the "race" field.
func RaceEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRace), v))
	})
}

// RaceNEQ applies the NEQ predicate on the "race" field.
func RaceNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRace), v))
	})
}

// RaceIn applies the In predicate on the "race" field.
func RaceIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRace), v...))
	})
}

// RaceNotIn applies the NotIn predicate on the "race" field.
func RaceNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRace), v...))
	})
}

// RaceGT applies the GT predicate on the "race" field.
func RaceGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRace), v))
	})
}

// RaceGTE applies the GTE predicate on the "race" field.
func RaceGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRace), v))
	})
}

// RaceLT applies the LT predicate on the "race" field.
func RaceLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRace), v))
	})
}

// RaceLTE applies the LTE predicate on the "race" field.
func RaceLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRace), v))
	})
}

// RaceContains applies the Contains predicate on the "race" field.
func RaceContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRace), v))
	})
}

// RaceHasPrefix applies the HasPrefix predicate on the "race" field.
func RaceHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRace), v))
	})
}

// RaceHasSuffix applies the HasSuffix predicate on the "race" field.
func RaceHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRace), v))
	})
}

// RaceEqualFold applies the EqualFold predicate on the "race" field.
func RaceEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRace), v))
	})
}

// RaceContainsFold applies the ContainsFold predicate on the "race" field.
func RaceContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRace), v))
	})
}

// FlagsEQ applies the EQ predicate on the "flags" field.
func FlagsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldFlags), v))
	})
}

// FlagsNEQ applies the NEQ predicate on the "flags" field.
func FlagsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldFlags), v))
	})
}

// FlagsIn applies the In predicate on the "flags" field.
func FlagsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldFlags), v...))
	})
}

// FlagsNotIn applies the NotIn predicate on the "flags" field.
func FlagsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldFlags), v...))
	})
}

// FlagsGT applies the GT predicate on the "flags" field.
func FlagsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldFlags), v))
	})
}

// FlagsGTE applies the GTE predicate on the "flags" field.
func FlagsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldFlags), v))
	})
}

// FlagsLT applies the LT predicate on the "flags" field.
func FlagsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldFlags), v))
	})
}

// FlagsLTE applies the LTE predicate on the "flags" field.
func FlagsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldFlags), v))
	})
}

// FlagsContains applies the Contains predicate on the "flags" field.
func FlagsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldFlags), v))
	})
}

// FlagsHasPrefix applies the HasPrefix predicate on the "flags" field.
func FlagsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldFlags), v))
	})
}

// FlagsHasSuffix applies the HasSuffix predicate on the "flags" field.
func FlagsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldFlags), v))
	})
}

// FlagsEqualFold applies the EqualFold predicate on the "flags" field.
func FlagsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldFlags), v))
	})
}

// FlagsContainsFold applies the ContainsFold predicate on the "flags" field.
func FlagsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldFlags), v))
	})
}

// QuickslotsEQ applies the EQ predicate on the "quickslots" field.
func QuickslotsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuickslots), v))
	})
}

// QuickslotsNEQ applies the NEQ predicate on the "quickslots" field.
func QuickslotsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldQuickslots), v))
	})
}

// QuickslotsIn applies the In predicate on the "quickslots" field.
func QuickslotsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldQuickslots), v...))
	})
}

// QuickslotsNotIn applies the NotIn predicate on the "quickslots" field.
func QuickslotsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldQuickslots), v...))
	})
}

// QuickslotsGT applies the GT predicate on the "quickslots" field.
func QuickslotsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldQuickslots), v))
	})
}

// QuickslotsGTE applies the GTE predicate on the "quickslots" field.
func QuickslotsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldQuickslots), v))
	})
}

// QuickslotsLT applies the LT predicate on the "quickslots" field.
func QuickslotsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldQuickslots), v))
	})
}

// QuickslotsLTE applies the LTE predicate on the "quickslots" field.
func QuickslotsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldQuickslots), v))
	})
}

// QuickslotsContains applies the Contains predicate on the "quickslots" field.
func QuickslotsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldQuickslots), v))
	})
}

// QuickslotsHasPrefix applies the HasPrefix predicate on the "quickslots" field.
func QuickslotsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldQuickslots), v))
	})
}

// QuickslotsHasSuffix applies the HasSuffix predicate on the "quickslots" field.
func QuickslotsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldQuickslots), v))
	})
}

// QuickslotsEqualFold applies the EqualFold predicate on the "quickslots" field.
func QuickslotsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldQuickslots), v))
	})
}

// QuickslotsContainsFold applies the ContainsFold predicate on the "quickslots" field.
func QuickslotsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldQuickslots), v))
	})
}

// QuestsEQ applies the EQ predicate on the "quests" field.
func QuestsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldQuests), v))
	})
}

// QuestsNEQ applies the NEQ predicate on the "quests" field.
func QuestsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldQuests), v))
	})
}

// QuestsIn applies the In predicate on the "quests" field.
func QuestsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldQuests), v...))
	})
}

// QuestsNotIn applies the NotIn predicate on the "quests" field.
func QuestsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldQuests), v...))
	})
}

// QuestsGT applies the GT predicate on the "quests" field.
func QuestsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldQuests), v))
	})
}

// QuestsGTE applies the GTE predicate on the "quests" field.
func QuestsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldQuests), v))
	})
}

// QuestsLT applies the LT predicate on the "quests" field.
func QuestsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldQuests), v))
	})
}

// QuestsLTE applies the LTE predicate on the "quests" field.
func QuestsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldQuests), v))
	})
}

// QuestsContains applies the Contains predicate on the "quests" field.
func QuestsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldQuests), v))
	})
}

// QuestsHasPrefix applies the HasPrefix predicate on the "quests" field.
func QuestsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldQuests), v))
	})
}

// QuestsHasSuffix applies the HasSuffix predicate on the "quests" field.
func QuestsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldQuests), v))
	})
}

// QuestsEqualFold applies the EqualFold predicate on the "quests" field.
func QuestsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldQuests), v))
	})
}

// QuestsContainsFold applies the ContainsFold predicate on the "quests" field.
func QuestsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldQuests), v))
	})
}

// GuildEQ applies the EQ predicate on the "guild" field.
func GuildEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGuild), v))
	})
}

// GuildNEQ applies the NEQ predicate on the "guild" field.
func GuildNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGuild), v))
	})
}

// GuildIn applies the In predicate on the "guild" field.
func GuildIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGuild), v...))
	})
}

// GuildNotIn applies the NotIn predicate on the "guild" field.
func GuildNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGuild), v...))
	})
}

// GuildGT applies the GT predicate on the "guild" field.
func GuildGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGuild), v))
	})
}

// GuildGTE applies the GTE predicate on the "guild" field.
func GuildGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGuild), v))
	})
}

// GuildLT applies the LT predicate on the "guild" field.
func GuildLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGuild), v))
	})
}

// GuildLTE applies the LTE predicate on the "guild" field.
func GuildLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGuild), v))
	})
}

// GuildContains applies the Contains predicate on the "guild" field.
func GuildContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldGuild), v))
	})
}

// GuildHasPrefix applies the HasPrefix predicate on the "guild" field.
func GuildHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldGuild), v))
	})
}

// GuildHasSuffix applies the HasSuffix predicate on the "guild" field.
func GuildHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldGuild), v))
	})
}

// GuildEqualFold applies the EqualFold predicate on the "guild" field.
func GuildEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldGuild), v))
	})
}

// GuildContainsFold applies the ContainsFold predicate on the "guild" field.
func GuildContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldGuild), v))
	})
}

// KillsEQ applies the EQ predicate on the "kills" field.
func KillsEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldKills), v))
	})
}

// KillsNEQ applies the NEQ predicate on the "kills" field.
func KillsNEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldKills), v))
	})
}

// KillsIn applies the In predicate on the "kills" field.
func KillsIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldKills), v...))
	})
}

// KillsNotIn applies the NotIn predicate on the "kills" field.
func KillsNotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldKills), v...))
	})
}

// KillsGT applies the GT predicate on the "kills" field.
func KillsGT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldKills), v))
	})
}

// KillsGTE applies the GTE predicate on the "kills" field.
func KillsGTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldKills), v))
	})
}

// KillsLT applies the LT predicate on the "kills" field.
func KillsLT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldKills), v))
	})
}

// KillsLTE applies the LTE predicate on the "kills" field.
func KillsLTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldKills), v))
	})
}

// GoldEQ applies the EQ predicate on the "gold" field.
func GoldEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldGold), v))
	})
}

// GoldNEQ applies the NEQ predicate on the "gold" field.
func GoldNEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldGold), v))
	})
}

// GoldIn applies the In predicate on the "gold" field.
func GoldIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldGold), v...))
	})
}

// GoldNotIn applies the NotIn predicate on the "gold" field.
func GoldNotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldGold), v...))
	})
}

// GoldGT applies the GT predicate on the "gold" field.
func GoldGT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldGold), v))
	})
}

// GoldGTE applies the GTE predicate on the "gold" field.
func GoldGTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldGold), v))
	})
}

// GoldLT applies the LT predicate on the "gold" field.
func GoldLT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldGold), v))
	})
}

// GoldLTE applies the LTE predicate on the "gold" field.
func GoldLTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldGold), v))
	})
}

// SkillsEQ applies the EQ predicate on the "skills" field.
func SkillsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSkills), v))
	})
}

// SkillsNEQ applies the NEQ predicate on the "skills" field.
func SkillsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSkills), v))
	})
}

// SkillsIn applies the In predicate on the "skills" field.
func SkillsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSkills), v...))
	})
}

// SkillsNotIn applies the NotIn predicate on the "skills" field.
func SkillsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSkills), v...))
	})
}

// SkillsGT applies the GT predicate on the "skills" field.
func SkillsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSkills), v))
	})
}

// SkillsGTE applies the GTE predicate on the "skills" field.
func SkillsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSkills), v))
	})
}

// SkillsLT applies the LT predicate on the "skills" field.
func SkillsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSkills), v))
	})
}

// SkillsLTE applies the LTE predicate on the "skills" field.
func SkillsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSkills), v))
	})
}

// SkillsContains applies the Contains predicate on the "skills" field.
func SkillsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSkills), v))
	})
}

// SkillsHasPrefix applies the HasPrefix predicate on the "skills" field.
func SkillsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSkills), v))
	})
}

// SkillsHasSuffix applies the HasSuffix predicate on the "skills" field.
func SkillsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSkills), v))
	})
}

// SkillsEqualFold applies the EqualFold predicate on the "skills" field.
func SkillsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSkills), v))
	})
}

// SkillsContainsFold applies the ContainsFold predicate on the "skills" field.
func SkillsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSkills), v))
	})
}

// PetsEQ applies the EQ predicate on the "pets" field.
func PetsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldPets), v))
	})
}

// PetsNEQ applies the NEQ predicate on the "pets" field.
func PetsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldPets), v))
	})
}

// PetsIn applies the In predicate on the "pets" field.
func PetsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldPets), v...))
	})
}

// PetsNotIn applies the NotIn predicate on the "pets" field.
func PetsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldPets), v...))
	})
}

// PetsGT applies the GT predicate on the "pets" field.
func PetsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldPets), v))
	})
}

// PetsGTE applies the GTE predicate on the "pets" field.
func PetsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldPets), v))
	})
}

// PetsLT applies the LT predicate on the "pets" field.
func PetsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldPets), v))
	})
}

// PetsLTE applies the LTE predicate on the "pets" field.
func PetsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldPets), v))
	})
}

// PetsContains applies the Contains predicate on the "pets" field.
func PetsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldPets), v))
	})
}

// PetsHasPrefix applies the HasPrefix predicate on the "pets" field.
func PetsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldPets), v))
	})
}

// PetsHasSuffix applies the HasSuffix predicate on the "pets" field.
func PetsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldPets), v))
	})
}

// PetsEqualFold applies the EqualFold predicate on the "pets" field.
func PetsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldPets), v))
	})
}

// PetsContainsFold applies the ContainsFold predicate on the "pets" field.
func PetsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldPets), v))
	})
}

// HealthEQ applies the EQ predicate on the "health" field.
func HealthEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldHealth), v))
	})
}

// HealthNEQ applies the NEQ predicate on the "health" field.
func HealthNEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldHealth), v))
	})
}

// HealthIn applies the In predicate on the "health" field.
func HealthIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldHealth), v...))
	})
}

// HealthNotIn applies the NotIn predicate on the "health" field.
func HealthNotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldHealth), v...))
	})
}

// HealthGT applies the GT predicate on the "health" field.
func HealthGT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldHealth), v))
	})
}

// HealthGTE applies the GTE predicate on the "health" field.
func HealthGTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldHealth), v))
	})
}

// HealthLT applies the LT predicate on the "health" field.
func HealthLT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldHealth), v))
	})
}

// HealthLTE applies the LTE predicate on the "health" field.
func HealthLTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldHealth), v))
	})
}

// ManaEQ applies the EQ predicate on the "mana" field.
func ManaEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldMana), v))
	})
}

// ManaNEQ applies the NEQ predicate on the "mana" field.
func ManaNEQ(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldMana), v))
	})
}

// ManaIn applies the In predicate on the "mana" field.
func ManaIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldMana), v...))
	})
}

// ManaNotIn applies the NotIn predicate on the "mana" field.
func ManaNotIn(vs ...int) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldMana), v...))
	})
}

// ManaGT applies the GT predicate on the "mana" field.
func ManaGT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldMana), v))
	})
}

// ManaGTE applies the GTE predicate on the "mana" field.
func ManaGTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldMana), v))
	})
}

// ManaLT applies the LT predicate on the "mana" field.
func ManaLT(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldMana), v))
	})
}

// ManaLTE applies the LTE predicate on the "mana" field.
func ManaLTE(v int) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldMana), v))
	})
}

// EquippedEQ applies the EQ predicate on the "equipped" field.
func EquippedEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldEquipped), v))
	})
}

// EquippedNEQ applies the NEQ predicate on the "equipped" field.
func EquippedNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldEquipped), v))
	})
}

// EquippedIn applies the In predicate on the "equipped" field.
func EquippedIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldEquipped), v...))
	})
}

// EquippedNotIn applies the NotIn predicate on the "equipped" field.
func EquippedNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldEquipped), v...))
	})
}

// EquippedGT applies the GT predicate on the "equipped" field.
func EquippedGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldEquipped), v))
	})
}

// EquippedGTE applies the GTE predicate on the "equipped" field.
func EquippedGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldEquipped), v))
	})
}

// EquippedLT applies the LT predicate on the "equipped" field.
func EquippedLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldEquipped), v))
	})
}

// EquippedLTE applies the LTE predicate on the "equipped" field.
func EquippedLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldEquipped), v))
	})
}

// EquippedContains applies the Contains predicate on the "equipped" field.
func EquippedContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldEquipped), v))
	})
}

// EquippedHasPrefix applies the HasPrefix predicate on the "equipped" field.
func EquippedHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldEquipped), v))
	})
}

// EquippedHasSuffix applies the HasSuffix predicate on the "equipped" field.
func EquippedHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldEquipped), v))
	})
}

// EquippedEqualFold applies the EqualFold predicate on the "equipped" field.
func EquippedEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldEquipped), v))
	})
}

// EquippedContainsFold applies the ContainsFold predicate on the "equipped" field.
func EquippedContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldEquipped), v))
	})
}

// LefthandEQ applies the EQ predicate on the "lefthand" field.
func LefthandEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldLefthand), v))
	})
}

// LefthandNEQ applies the NEQ predicate on the "lefthand" field.
func LefthandNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldLefthand), v))
	})
}

// LefthandIn applies the In predicate on the "lefthand" field.
func LefthandIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldLefthand), v...))
	})
}

// LefthandNotIn applies the NotIn predicate on the "lefthand" field.
func LefthandNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldLefthand), v...))
	})
}

// LefthandGT applies the GT predicate on the "lefthand" field.
func LefthandGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldLefthand), v))
	})
}

// LefthandGTE applies the GTE predicate on the "lefthand" field.
func LefthandGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldLefthand), v))
	})
}

// LefthandLT applies the LT predicate on the "lefthand" field.
func LefthandLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldLefthand), v))
	})
}

// LefthandLTE applies the LTE predicate on the "lefthand" field.
func LefthandLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldLefthand), v))
	})
}

// LefthandContains applies the Contains predicate on the "lefthand" field.
func LefthandContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldLefthand), v))
	})
}

// LefthandHasPrefix applies the HasPrefix predicate on the "lefthand" field.
func LefthandHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldLefthand), v))
	})
}

// LefthandHasSuffix applies the HasSuffix predicate on the "lefthand" field.
func LefthandHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldLefthand), v))
	})
}

// LefthandEqualFold applies the EqualFold predicate on the "lefthand" field.
func LefthandEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldLefthand), v))
	})
}

// LefthandContainsFold applies the ContainsFold predicate on the "lefthand" field.
func LefthandContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldLefthand), v))
	})
}

// RighthandEQ applies the EQ predicate on the "righthand" field.
func RighthandEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldRighthand), v))
	})
}

// RighthandNEQ applies the NEQ predicate on the "righthand" field.
func RighthandNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldRighthand), v))
	})
}

// RighthandIn applies the In predicate on the "righthand" field.
func RighthandIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldRighthand), v...))
	})
}

// RighthandNotIn applies the NotIn predicate on the "righthand" field.
func RighthandNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldRighthand), v...))
	})
}

// RighthandGT applies the GT predicate on the "righthand" field.
func RighthandGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldRighthand), v))
	})
}

// RighthandGTE applies the GTE predicate on the "righthand" field.
func RighthandGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldRighthand), v))
	})
}

// RighthandLT applies the LT predicate on the "righthand" field.
func RighthandLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldRighthand), v))
	})
}

// RighthandLTE applies the LTE predicate on the "righthand" field.
func RighthandLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldRighthand), v))
	})
}

// RighthandContains applies the Contains predicate on the "righthand" field.
func RighthandContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldRighthand), v))
	})
}

// RighthandHasPrefix applies the HasPrefix predicate on the "righthand" field.
func RighthandHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldRighthand), v))
	})
}

// RighthandHasSuffix applies the HasSuffix predicate on the "righthand" field.
func RighthandHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldRighthand), v))
	})
}

// RighthandEqualFold applies the EqualFold predicate on the "righthand" field.
func RighthandEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldRighthand), v))
	})
}

// RighthandContainsFold applies the ContainsFold predicate on the "righthand" field.
func RighthandContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldRighthand), v))
	})
}

// SpellsEQ applies the EQ predicate on the "spells" field.
func SpellsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSpells), v))
	})
}

// SpellsNEQ applies the NEQ predicate on the "spells" field.
func SpellsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSpells), v))
	})
}

// SpellsIn applies the In predicate on the "spells" field.
func SpellsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSpells), v...))
	})
}

// SpellsNotIn applies the NotIn predicate on the "spells" field.
func SpellsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSpells), v...))
	})
}

// SpellsGT applies the GT predicate on the "spells" field.
func SpellsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSpells), v))
	})
}

// SpellsGTE applies the GTE predicate on the "spells" field.
func SpellsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSpells), v))
	})
}

// SpellsLT applies the LT predicate on the "spells" field.
func SpellsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSpells), v))
	})
}

// SpellsLTE applies the LTE predicate on the "spells" field.
func SpellsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSpells), v))
	})
}

// SpellsContains applies the Contains predicate on the "spells" field.
func SpellsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSpells), v))
	})
}

// SpellsHasPrefix applies the HasPrefix predicate on the "spells" field.
func SpellsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSpells), v))
	})
}

// SpellsHasSuffix applies the HasSuffix predicate on the "spells" field.
func SpellsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSpells), v))
	})
}

// SpellsEqualFold applies the EqualFold predicate on the "spells" field.
func SpellsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSpells), v))
	})
}

// SpellsContainsFold applies the ContainsFold predicate on the "spells" field.
func SpellsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSpells), v))
	})
}

// SpellbookEQ applies the EQ predicate on the "spellbook" field.
func SpellbookEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSpellbook), v))
	})
}

// SpellbookNEQ applies the NEQ predicate on the "spellbook" field.
func SpellbookNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSpellbook), v))
	})
}

// SpellbookIn applies the In predicate on the "spellbook" field.
func SpellbookIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSpellbook), v...))
	})
}

// SpellbookNotIn applies the NotIn predicate on the "spellbook" field.
func SpellbookNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSpellbook), v...))
	})
}

// SpellbookGT applies the GT predicate on the "spellbook" field.
func SpellbookGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSpellbook), v))
	})
}

// SpellbookGTE applies the GTE predicate on the "spellbook" field.
func SpellbookGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSpellbook), v))
	})
}

// SpellbookLT applies the LT predicate on the "spellbook" field.
func SpellbookLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSpellbook), v))
	})
}

// SpellbookLTE applies the LTE predicate on the "spellbook" field.
func SpellbookLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSpellbook), v))
	})
}

// SpellbookContains applies the Contains predicate on the "spellbook" field.
func SpellbookContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSpellbook), v))
	})
}

// SpellbookHasPrefix applies the HasPrefix predicate on the "spellbook" field.
func SpellbookHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSpellbook), v))
	})
}

// SpellbookHasSuffix applies the HasSuffix predicate on the "spellbook" field.
func SpellbookHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSpellbook), v))
	})
}

// SpellbookEqualFold applies the EqualFold predicate on the "spellbook" field.
func SpellbookEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSpellbook), v))
	})
}

// SpellbookContainsFold applies the ContainsFold predicate on the "spellbook" field.
func SpellbookContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSpellbook), v))
	})
}

// BagsEQ applies the EQ predicate on the "bags" field.
func BagsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldBags), v))
	})
}

// BagsNEQ applies the NEQ predicate on the "bags" field.
func BagsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldBags), v))
	})
}

// BagsIn applies the In predicate on the "bags" field.
func BagsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldBags), v...))
	})
}

// BagsNotIn applies the NotIn predicate on the "bags" field.
func BagsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldBags), v...))
	})
}

// BagsGT applies the GT predicate on the "bags" field.
func BagsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldBags), v))
	})
}

// BagsGTE applies the GTE predicate on the "bags" field.
func BagsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldBags), v))
	})
}

// BagsLT applies the LT predicate on the "bags" field.
func BagsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldBags), v))
	})
}

// BagsLTE applies the LTE predicate on the "bags" field.
func BagsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldBags), v))
	})
}

// BagsContains applies the Contains predicate on the "bags" field.
func BagsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldBags), v))
	})
}

// BagsHasPrefix applies the HasPrefix predicate on the "bags" field.
func BagsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldBags), v))
	})
}

// BagsHasSuffix applies the HasSuffix predicate on the "bags" field.
func BagsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldBags), v))
	})
}

// BagsEqualFold applies the EqualFold predicate on the "bags" field.
func BagsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldBags), v))
	})
}

// BagsContainsFold applies the ContainsFold predicate on the "bags" field.
func BagsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldBags), v))
	})
}

// SheathsEQ applies the EQ predicate on the "sheaths" field.
func SheathsEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EQ(s.C(FieldSheaths), v))
	})
}

// SheathsNEQ applies the NEQ predicate on the "sheaths" field.
func SheathsNEQ(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.NEQ(s.C(FieldSheaths), v))
	})
}

// SheathsIn applies the In predicate on the "sheaths" field.
func SheathsIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.In(s.C(FieldSheaths), v...))
	})
}

// SheathsNotIn applies the NotIn predicate on the "sheaths" field.
func SheathsNotIn(vs ...string) predicate.Character {
	v := make([]interface{}, len(vs))
	for i := range v {
		v[i] = vs[i]
	}
	return predicate.Character(func(s *sql.Selector) {
		// if not arguments were provided, append the FALSE constants,
		// since we can't apply "IN ()". This will make this predicate falsy.
		if len(v) == 0 {
			s.Where(sql.False())
			return
		}
		s.Where(sql.NotIn(s.C(FieldSheaths), v...))
	})
}

// SheathsGT applies the GT predicate on the "sheaths" field.
func SheathsGT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GT(s.C(FieldSheaths), v))
	})
}

// SheathsGTE applies the GTE predicate on the "sheaths" field.
func SheathsGTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.GTE(s.C(FieldSheaths), v))
	})
}

// SheathsLT applies the LT predicate on the "sheaths" field.
func SheathsLT(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LT(s.C(FieldSheaths), v))
	})
}

// SheathsLTE applies the LTE predicate on the "sheaths" field.
func SheathsLTE(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.LTE(s.C(FieldSheaths), v))
	})
}

// SheathsContains applies the Contains predicate on the "sheaths" field.
func SheathsContains(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.Contains(s.C(FieldSheaths), v))
	})
}

// SheathsHasPrefix applies the HasPrefix predicate on the "sheaths" field.
func SheathsHasPrefix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasPrefix(s.C(FieldSheaths), v))
	})
}

// SheathsHasSuffix applies the HasSuffix predicate on the "sheaths" field.
func SheathsHasSuffix(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.HasSuffix(s.C(FieldSheaths), v))
	})
}

// SheathsEqualFold applies the EqualFold predicate on the "sheaths" field.
func SheathsEqualFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.EqualFold(s.C(FieldSheaths), v))
	})
}

// SheathsContainsFold applies the ContainsFold predicate on the "sheaths" field.
func SheathsContainsFold(v string) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s.Where(sql.ContainsFold(s.C(FieldSheaths), v))
	})
}

// And groups predicates with the AND operator between them.
func And(predicates ...predicate.Character) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for _, p := range predicates {
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Or groups predicates with the OR operator between them.
func Or(predicates ...predicate.Character) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		s1 := s.Clone().SetP(nil)
		for i, p := range predicates {
			if i > 0 {
				s1.Or()
			}
			p(s1)
		}
		s.Where(s1.P())
	})
}

// Not applies the not operator on the given predicate.
func Not(p predicate.Character) predicate.Character {
	return predicate.Character(func(s *sql.Selector) {
		p(s.Not())
	})
}
